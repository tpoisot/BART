var documenterSearchIndex = {"docs":
[{"location":"trees/#Trees","page":"Trees","title":"Trees","text":"","category":"section"},{"location":"trees/#Overview-of-the-types","page":"Trees","title":"Overview of the types","text":"","category":"section"},{"location":"trees/","page":"Trees","title":"Trees","text":"Tree","category":"page"},{"location":"trees/#BART.Tree","page":"Trees","title":"BART.Tree","text":"Tree\n\nA tree is a simple datastructure that binds a response y, a matrix of features X, and the tree itself stored in root. When the type is constructed without a root, the default behavior is to create a root that is a terminal node of depth 0, with a response set to the average of y.\n\n\n\n\n\n","category":"type"},{"location":"trees/","page":"Trees","title":"Trees","text":"DecisionNode","category":"page"},{"location":"trees/#BART.DecisionNode","page":"Trees","title":"BART.DecisionNode","text":"DecisionNode{T}\n\nA decision node that works for both classification and regression.\n\n\n\n\n\n","category":"type"},{"location":"trees/#Tree-utilities","page":"Trees","title":"Tree utilities","text":"","category":"section"},{"location":"trees/","page":"Trees","title":"Trees","text":"BART.depth","category":"page"},{"location":"trees/#BART.depth","page":"Trees","title":"BART.depth","text":"depth(node::DecisionNode)\n\nReturns the depth of a node, which is stored in the node metadata.\n\n\n\n\n\ndepth(tree::Tree)\n\nReturns the depth of a tree, which is measured as the lower depth of its terminal nodes.\n\n\n\n\n\n","category":"function"},{"location":"moves/#Moves","page":"Moves","title":"Moves","text":"","category":"section"},{"location":"moves/","page":"Moves","title":"Moves","text":"All these methods are used to generate new proposals from the tree space. The order of argument is always the node first, and the tree second. It is always assumed that the node will point to a node contained within the tree, so that both will be modified. The node that is targeted by the modification is returned. For the swap! method, the parent node is given as argument.","category":"page"},{"location":"moves/#Moves-to-explore-the-trees-space","page":"Moves","title":"Moves to explore the trees space","text":"","category":"section"},{"location":"moves/","page":"Moves","title":"Moves","text":"grow!\nprune!\nchange!\nswap!","category":"page"},{"location":"moves/#BART.grow!","page":"Moves","title":"BART.grow!","text":"grow!(node::DecisionNode, tree::Tree)\n\nGrows the tree by splitting a terminal node. Note that the value of the variable used for the split is drawn from the values present within the instances that are included in the terminal node currently being split.\n\n\n\n\n\n","category":"function"},{"location":"moves/#BART.prune!","page":"Moves","title":"BART.prune!","text":"prune!(node::DecisionNode, tree::Tree)\n\nPrunes the tree by collapsing a node whose children are both terminal.\n\n\n\n\n\n","category":"function"},{"location":"moves/#BART.change!","page":"Moves","title":"BART.change!","text":"change!(node::DecisionNode, tree::Tree)\n\nChanges a decision node (regardless of the status of the children of this node) so that the feature and the value are re-drawn uniformly. This also updates the allocation of instances to all the downstream nodes in the tree.\n\n\n\n\n\n","category":"function"},{"location":"moves/#BART.swap!","page":"Moves","title":"BART.swap!","text":"swap!(node::DecisionNode, tree::Tree)\n\nChanges a decision node and one of its children by swapping their decision rules. This also updates the allocation of instances to all the downstream nodes in the tree.\n\n\n\n\n\n","category":"function"},{"location":"moves/#Tree-modification-utilities","page":"Moves","title":"Tree modification utilities","text":"","category":"section"},{"location":"moves/","page":"Moves","title":"Moves","text":"BART.createrule!\nBART.collapse!\nBART.update!","category":"page"},{"location":"moves/#BART.createrule!","page":"Moves","title":"BART.createrule!","text":"BART.createrule!(node::DecisionNode, tree::Tree)\n\nCreates a new rule for a tree, by assigning a random variable and value for the decision at this node. Calling this function will automatically update every node downstream of the new rule.\n\n\n\n\n\n","category":"function"},{"location":"moves/#BART.collapse!","page":"Moves","title":"BART.collapse!","text":"BART.collapse!(node::DecisionNode, tree::Tree)\n\nCollapses a decision tree by removing its decision rule, and destroying its left and right descendants.\n\n\n\n\n\n","category":"function"},{"location":"moves/#BART.update!","page":"Moves","title":"BART.update!","text":"BART.update!(node::DecisionNode, tree::Tree)\n\nPropagates changes to a tree by assigning the correct instances to each node. This method is called when the rules are changed, or when nodes are created/merged.\n\n\n\n\n\n","category":"function"},{"location":"#BART.jl","page":"BART.jl","title":"BART.jl","text":"","category":"section"},{"location":"","page":"BART.jl","title":"BART.jl","text":"Documentation for BART.jl","category":"page"},{"location":"datasets/#Datasets","page":"Datasets","title":"Datasets","text":"","category":"section"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"BART.bigfoot\nBART.friedman","category":"page"},{"location":"datasets/#BART.bigfoot","page":"Datasets","title":"BART.bigfoot","text":"BART.bigfoot\n\nObservations (and pseudo-absences) for BigFoot in the eastern United States. The predictors are 19 bioclimatic variables.\n\n\n\n\n\n","category":"function"},{"location":"datasets/#BART.friedman","page":"Datasets","title":"BART.friedman","text":"BART.friedman(x::Vector{Float64})\n\nGenerates one output of the Friedman 5-parameters function with no error term.\n\n\n\n\n\nBART.friedman(; n=20, p=3)\n\nGenerates n data points for the Friedman 5-parameters function, with an extra set of p predictors that have no effect on the value of y. The error term is in ùí©(0,1).\n\n\n\n\n\n","category":"function"}]
}
